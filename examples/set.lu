set = setmeta({
	mt = {
		__name = "set",
		__and = function(self, other) {
			let new = set()
			new.values = self.values:copy()
			for value in other.values {
				new:insert(value)
			}
			return new
		},
		__sub = function(self, other) {
			let new = set()
			new.values = self.values:copy()
			for value in other.values {
				new:remove(value)
			}
			return new
		},
		__or = function(self, other) {
			let new = set()
			for value in other.values {
				if self:contains(value) & other:contains(value) {
					new:insert(value)
				}
			}
			return new
		},
	},
	tostr = function(self) {
		return tostr(self.values)
	},
	insert = function(self, value) {
		if !self.values:contains(value) {
			self.values:push(value)
		}
	},
	remove = function(self, value) {
		let pos = self.values:pos(value)
		if pos != null {
			self.values:remove(pos)
		}
	},
	contains = function(self, value) {
		return self.values:contains(value)
	},
	sub = function(self, other) {
		for value in other.values {
			if !self.values:contains(value) {
				return false
			}
		}
		return true
	},
}, {
	__call = function(self, ...values) {
		let set = obj.copy(self)
		set.values = values
		return setmeta(set, self.mt)
	}
})

let nums = set(1, 2, 3, 4)
print(nums:tostr())
nums:insert(5)
nums:remove(4)
print(nums:tostr())
print(nums:contains(2))
print(nums:sub(set(0, 2)))
print(nums:sub(set(3, 2)))

let s1 = set(1, 2, 3)
let s2 = set(3, 4, 5)
print(s1:tostr(), s2:tostr())
let combined = s1 & s2
print(combined:tostr())
let subtracted = s1 - s2
print(subtracted:tostr())
let overlaping = s1 | s2
print(overlaping:tostr())